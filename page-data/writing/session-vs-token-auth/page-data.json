{"componentChunkName":"component---src-templates-markdown-page-js","path":"/writing/session-vs-token-auth","result":{"data":{"markdownRemark":{"html":"<p>Session based authentication is the classic way of doing authentication in a web application. Each sign-in passes back a key\nto the client. This key is associated with a record in a database linked to a user identity. Clients pass this key back to the server\nwhich then looks it up in the database to verify further interactions with the application.</p>\n<p>Token based authentication is the new kid on the block. Each sign-in passes back an encrypted blob of data (aka token) to the client that contains\nidentity information. Clients pass this token back to the server which can decrypt it and verify further interactions with the application.</p>\n<p>Although token based authentication has been getting more and more traction lately, I'm still quite fond of\nsession authentication. Although in theory token based auth is simpler and more scalable than session based auth, when it\ncomes to supporting the entire auth lifecycle (issuing/verifying/revoking) I believe it ends up being slightly\nmore complicated with pretty much the exact same scalability properties as session based auth. Let's compare how they stack up in more detail.</p>\n<h2>Session Authentication</h2>\n<p><em>Issuing:</em></p>\n<ol>\n<li>Authentication request with credentials is made to the server and verified.</li>\n<li>A session is inserted into the database.</li>\n<li>The session key is returned to the client.</li>\n</ol>\n<p><em>Verifying:</em></p>\n<ol>\n<li>A request is made to access a secure resource and comes along with a session key.</li>\n<li>A query is issued to the database to verify the validity/owner of the session key.</li>\n</ol>\n<p><em>Revoking:</em></p>\n<ol>\n<li>A request to revoke is made to the server for either a specific session or all sessions.</li>\n<li>A query is issued to the database to delete the relevant sessions.</li>\n</ol>\n<p><em>Scalability:</em></p>\n<p>All three lifecycle events involve interacting with the database.</p>\n<h2>Token Authentication (without revocation)</h2>\n<p><em>Issuing:</em></p>\n<ol>\n<li>Authentication request with credentials is made to the server and verified.</li>\n<li>A token is created with identity information and passed back to the client.</li>\n</ol>\n<p><em>Verifying:</em></p>\n<ol>\n<li>A request is made to access a secure resource and comes along with a token.</li>\n<li>The server decrypts that token to verify the validity/owner of the request.</li>\n</ol>\n<p><em>Revoking:</em></p>\n<p>The argument for doing away with support for revoking tokens is that in practice\nit's just not that important or commonly used functionality.</p>\n<p><em>Scalability:</em></p>\n<p>Issuing requires a lookup of credentials the same as with session authentication,\nbut no record insertion unlike session authentication. Verification requires no interaction with\nthe database at all! So long as we don't need to support revoking tokens, this seems like\na pretty cut and dry win for token authentication. But what happens when you need to support\nrevoking tokens?</p>\n<h2>Token Authentication (with revoked token blacklist)</h2>\n<p>There are a couple ways to support revocation with tokens. One could create a blacklist of tokens that are revoked,\nor one could store a whitelist of valid tokens. Let's start with the revoked token blacklist:</p>\n<p><em>Issuing:</em> Same as without revocation support above.</p>\n<p><em>Verifying:</em></p>\n<ol>\n<li>A request is made to access a secure resource and comes along with a token.</li>\n<li>The server checks the token blacklist in the database to verify it hasn't been revoked.</li>\n<li>The server decrypts that token to verify the validity/owner of the request.</li>\n</ol>\n<p><em>Revoking:</em></p>\n<ol>\n<li>A request to revoke a token is made to the server.</li>\n<li>A query is issued to the database to insert that token into the blacklist.</li>\n</ol>\n<p><em>Scalability:</em></p>\n<p>We've introduced a database lookup in token verification, so we lose most of the scaling\nbenefits of the token based approach. We retain the benefit that sign-ins still don't require\ndatabase inserts though, unlike session based auth.</p>\n<p><em>Constraints:</em></p>\n<p>One further constraint of the blacklist approach is the inability to revoke all tokens,\nsince we don't know all tokens that might be out there.</p>\n<h2>Token Authentication (with valid token whitelist)</h2>\n<p><em>Issuing:</em>:</p>\n<ol>\n<li>Authentication request with credentials is made to the server and verified.</li>\n<li>A token is created with identity information, then inserted into the database.</li>\n<li>The token is returned to the user.</li>\n</ol>\n<p><em>Verifying:</em>:</p>\n<ol>\n<li>A request is made to access a secure resource and comes along with a token.</li>\n<li>The server checks the token whitelist in the database to verify it hasn't been revoked.</li>\n<li>The server decrypts that token to verify the validity/owner of the request.</li>\n</ol>\n<p><em>Revoking:</em></p>\n<ol>\n<li>A request to revoke a specific token or all tokens is made to the server.</li>\n<li>A query is issued to the database to delete the relvant tokens from the whitelist.</li>\n</ol>\n<p><em>Scalability:</em></p>\n<p>Compared to token authentication without support for revoking tokens, we've added\na database insert to the issuing process, and a lookup to the verification process,\nnullifying any scalability benefit of tokens.</p>\n<p><em>Constraints:</em></p>\n<p>Unlike the blacklist approach, we can revoke all tokens with this approach.</p>","frontmatter":{"date":"May 31, 2020","path":"/writing/session-vs-token-auth","title":"Session vs. Token Based Authentication"}}},"pageContext":{}}}